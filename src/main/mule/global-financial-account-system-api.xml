<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns="http://www.mulesoft.org/schema/mule/core"
  xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
  xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns:db="http://www.mulesoft.org/schema/mule/db"
      xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
      http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
	http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
	http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd">

  <!-- GET /accounts - Business Logic Flow -->
  <flow name="get-accounts-business-logic" doc:name="get-accounts-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Global Accounts">
        <db:sql><![CDATA[
          SELECT a.*
          FROM global_accounts a
          WHERE
            (NULLIF(:globalId, '') IS NULL OR a.global_id = NULLIF(:globalId, '')::uuid)
            AND (COALESCE(:accountNumber, '') = '' OR a.account_number = :accountNumber)
            AND (COALESCE(:accountType, '') = '' OR a.account_type = :accountType)
            AND (NULLIF(:customerGlobalId, '') IS NULL OR EXISTS (
              SELECT 1 FROM global_account_owners ao
              WHERE ao.account_global_id = a.global_id
              AND ao.customer_global_id = NULLIF(:customerGlobalId, '')::uuid
            ))
          ORDER BY a.created_at DESC
          LIMIT CAST(COALESCE(:limit, '100') AS integer) OFFSET CAST(COALESCE(:offset, '0') AS integer)
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload default {}]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Store Accounts">
        <ee:variables>
          <ee:set-variable variableName="accounts"><![CDATA[%dw 2.0
output application/java
---
if (payload is Array) payload else [payload] default []]]></ee:set-variable>
        </ee:variables>
      </ee:transform>

      <choice doc:name="Has Accounts?">
        <when expression="#[sizeOf(vars.accounts) > 0]">
          <ee:transform doc:name="Extract Account Global IDs">
            <ee:variables>
              <ee:set-variable variableName="accountGlobalIdsList"><![CDATA[%dw 2.0
output application/java
---
vars.accounts map ((acc) -> acc.global_id)]]></ee:set-variable>
            </ee:variables>
          </ee:transform>
          <choice doc:name="Has Account Global IDs?">
            <when expression="#[sizeOf(vars.accountGlobalIdsList) > 0]">
              <foreach collection="#[vars.accountGlobalIdsList]" doc:name="For Each Account Global ID">
                <db:select config-ref="Database_Config" doc:name="Select Account Owners">
                  <db:sql><![CDATA[
                    SELECT account_global_id, customer_global_id, relationship_type
                    FROM global_account_owners
                    WHERE account_global_id = :accountGlobalId::uuid
                  ]]></db:sql>
                  <db:input-parameters><![CDATA[#[{
                    accountGlobalId: payload
                  }]]]></db:input-parameters>
                </db:select>
                <ee:transform doc:name="Collect Owners">
                  <ee:variables>
                    <ee:set-variable variableName="owners"><![CDATA[%dw 2.0
output application/java
---
if (vars.owners == null) payload else vars.owners ++ payload]]></ee:set-variable>
                  </ee:variables>
                </ee:transform>
              </foreach>
              <set-payload value="#[vars.owners default []]" doc:name="Set Owners Payload"/>
            </when>
            <otherwise>
              <set-payload value="#[[]]" doc:name="Set Empty Array"/>
            </otherwise>
          </choice>
        </when>
        <otherwise>
          <set-payload value="#[[]]" doc:name="Set Empty Array"/>
        </otherwise>
      </choice>

      <ee:transform doc:name="Transform to Account Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
var accounts = vars.accounts
var owners = payload
var ownersByAccount = owners groupBy $.account_global_id
---
accounts map ((account) -> {
  id: account.id as String,
  globalId: account.global_id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: (ownersByAccount[account.global_id as String] default []) map ((owner) -> {
    customerGlobalId: owner.customer_global_id as String,
    relationshipType: owner.relationship_type
  }),
  createdAt: account.created_at,
  updatedAt: account.updated_at
})]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="200" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying the database",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- POST /accounts - Business Logic Flow -->
  <flow name="upsert-account-business-logic" doc:name="upsert-account-business-logic">
    <logger level="INFO" message="Initial payload - accountNumber: #[payload.accountNumber], payload: #[payload]" doc:name="Log Initial Payload" />
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeAccountType(at) = 
  if (at == null) null
  else if (at as String == "Checking" or at as String == "checking" or at as String == "CHECKING") "Checking"
  else if (at as String == "Savings" or at as String == "savings" or at as String == "SAVINGS") "Savings"
  else if (at as String == "MoneyMarket" or at as String == "moneymarket" or at as String == "MONEYMARKET") "MoneyMarket"
  else if (at as String == "CertificateOfDeposit" or at as String == "certificateofdeposit" or at as String == "CERTIFICATEOFDEPOSIT") "CertificateOfDeposit"
  else if (at as String == "Other" or at as String == "other" or at as String == "OTHER") "Other"
  else at as String
fun normalizeAccountStatus(s) = 
  if (s == null) "Active"
  else if (s as String == "Active" or s as String == "active" or s as String == "ACTIVE") "Active"
  else if (s as String == "Inactive" or s as String == "inactive" or s as String == "INACTIVE") "Inactive"
  else if (s as String == "Frozen" or s as String == "frozen" or s as String == "FROZEN") "Frozen"
  else if (s as String == "Closed" or s as String == "closed" or s as String == "CLOSED") "Closed"
  else s as String
var transformedData = {
  global_id: payload.globalId default null,
  account_number: payload.accountNumber default "",
  account_type: normalizeAccountType(payload.accountType) default "Checking",
  account_name: payload.accountName default null,
  currency: payload.currency default "USD",
  balance: payload.balance default 0.00,
  available_balance: payload.availableBalance default payload.balance default 0.00,
  status: normalizeAccountStatus(payload.status),
  opened_date: payload.openedDate default null,
  closed_date: payload.closedDate default null,
  interest_rate: payload.interestRate default null
}
---
transformedData]]></ee:set-payload>
      </ee:message>
      <ee:variables>
        <ee:set-variable variableName="accountData"><![CDATA[%dw 2.0
output application/java
fun normalizeAccountType(at) = 
  if (at == null) null
  else if (at as String == "Checking" or at as String == "checking" or at as String == "CHECKING") "Checking"
  else if (at as String == "Savings" or at as String == "savings" or at as String == "SAVINGS") "Savings"
  else if (at as String == "MoneyMarket" or at as String == "moneymarket" or at as String == "MONEYMARKET") "MoneyMarket"
  else if (at as String == "CertificateOfDeposit" or at as String == "certificateofdeposit" or at as String == "CERTIFICATEOFDEPOSIT") "CertificateOfDeposit"
  else if (at as String == "Other" or at as String == "other" or at as String == "OTHER") "Other"
  else at as String
fun normalizeAccountStatus(s) = 
  if (s == null) "Active"
  else if (s as String == "Active" or s as String == "active" or s as String == "ACTIVE") "Active"
  else if (s as String == "Inactive" or s as String == "inactive" or s as String == "INACTIVE") "Inactive"
  else if (s as String == "Frozen" or s as String == "frozen" or s as String == "FROZEN") "Frozen"
  else if (s as String == "Closed" or s as String == "closed" or s as String == "CLOSED") "Closed"
  else s as String
---
{
  global_id: payload.globalId default null,
  account_number: payload.accountNumber default "",
  account_type: normalizeAccountType(payload.accountType) default "Checking",
  account_name: payload.accountName default null,
  currency: payload.currency default "USD",
  balance: payload.balance default 0.00,
  available_balance: payload.availableBalance default payload.balance default 0.00,
  status: normalizeAccountStatus(payload.status),
  opened_date: payload.openedDate default null,
  closed_date: payload.closedDate default null,
  interest_rate: payload.interestRate default null
}]]></ee:set-variable>
        <ee:set-variable variableName="owners"><![CDATA[%dw 2.0
output application/java
---
payload.owners default []]]></ee:set-variable>
      </ee:variables>
    </ee:transform>

    <set-variable value="#[vars.accountData.account_number]" variableName="accountNumber" doc:name="Store Account Number" />
    <set-variable value="#[vars.accountData.global_id]" variableName="globalId" doc:name="Store Global ID" />
    <logger level="INFO" message="Before Prepare DB Parameters - vars.accountData: #[vars.accountData]" doc:name="Log Account Data Before Transform" />

    <logger level="INFO" message="Before Prepare DB Parameters - vars.accountData: #[vars.accountData], account_number: #[vars.accountData.account_number]" doc:name="Log Account Data Before Transform" />
    <ee:transform doc:name="Prepare DB Parameters">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
var data = vars.accountData
---
{
  global_id: data.global_id,
  account_number: data.account_number default "",
  account_type: data.account_type default "",
  account_name: data.account_name,
  currency: data.currency default "USD",
  balance: data.balance default 0.00,
  available_balance: data.available_balance default data.balance default 0.00,
  status: data.status default "Active",
  opened_date: data.opened_date,
  closed_date: data.closed_date,
  interest_rate: data.interest_rate
}]]></ee:set-payload>
      </ee:message>
    </ee:transform>
    <logger level="INFO" message="After Prepare DB Parameters - payload: #[payload], account_number: #[payload.account_number]" doc:name="Log Payload After Transform" />

    <try doc:name="Try">
      <db:insert config-ref="Database_Config" doc:name="Upsert Account">
        <db:sql><![CDATA[
          INSERT INTO global_accounts (
            global_id, account_number, account_type, account_name, currency,
            balance, available_balance, status, opened_date, closed_date, interest_rate
          )
          VALUES (
            COALESCE(:global_id::uuid, gen_random_uuid()),
            :account_number, :account_type, :account_name, :currency,
            :balance, :available_balance, :status, :opened_date::date, :closed_date::date, :interest_rate
          )
          ON CONFLICT (global_id) DO UPDATE SET
            account_number = EXCLUDED.account_number,
            account_type = EXCLUDED.account_type,
            account_name = EXCLUDED.account_name,
            currency = EXCLUDED.currency,
            balance = EXCLUDED.balance,
            available_balance = EXCLUDED.available_balance,
            status = EXCLUDED.status,
            opened_date = EXCLUDED.opened_date,
            closed_date = EXCLUDED.closed_date,
            interest_rate = EXCLUDED.interest_rate,
            updated_at = CURRENT_TIMESTAMP
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:insert>

      <db:select config-ref="Database_Config" doc:name="Select Upserted Account">
        <db:sql><![CDATA[
          SELECT *
          FROM global_accounts
          WHERE account_number = :accountNumber
          ORDER BY updated_at DESC, created_at DESC
          LIMIT 1
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          accountNumber: vars.accountNumber
        }]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Store Account">
        <ee:variables>
          <ee:set-variable variableName="account"><![CDATA[%dw 2.0
output application/java
---
payload[0]]]></ee:set-variable>
          <ee:set-variable variableName="accountGlobalId"><![CDATA[%dw 2.0
output application/java
---
payload[0].global_id]]></ee:set-variable>
        </ee:variables>
      </ee:transform>

      <choice doc:name="Has Owners?">
        <when expression="#[sizeOf(vars.owners) > 0]">
          <db:delete config-ref="Database_Config" doc:name="Delete Existing Owners">
            <db:sql><![CDATA[
              DELETE FROM global_account_owners
              WHERE account_global_id = :accountGlobalId::uuid
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{
              accountGlobalId: vars.accountGlobalId
            }]]]></db:input-parameters>
          </db:delete>

          <ee:transform doc:name="Transform Owners for Insert">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeRelationshipType(rt) = 
  if (rt == null) "Primary"
  else if (rt as String == "Primary" or rt as String == "primary" or rt as String == "PRIMARY") "Primary"
  else if (rt as String == "Joint" or rt as String == "joint" or rt as String == "JOINT") "Joint"
  else if (rt as String == "Beneficiary" or rt as String == "beneficiary" or rt as String == "BENEFICIARY") "Beneficiary"
  else rt as String
---
vars.owners map ((owner) -> {
  account_global_id: vars.accountGlobalId,
  customer_global_id: owner.customerGlobalId,
  relationship_type: normalizeRelationshipType(owner.relationshipType)
})]]></ee:set-payload>
            </ee:message>
          </ee:transform>

          <foreach doc:name="Insert Owners">
            <db:insert config-ref="Database_Config" doc:name="Insert Owner">
              <db:sql><![CDATA[
                INSERT INTO global_account_owners (
                  account_global_id, customer_global_id, relationship_type
                )
                VALUES (
                  :account_global_id::uuid, :customer_global_id::uuid, :relationship_type
                )
                ON CONFLICT (account_global_id, customer_global_id) DO UPDATE SET
                  relationship_type = EXCLUDED.relationship_type
              ]]></db:sql>
              <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
            </db:insert>
          </foreach>
        </when>
      </choice>

      <db:select config-ref="Database_Config" doc:name="Get Owners">
        <db:sql><![CDATA[
          SELECT customer_global_id, relationship_type
          FROM global_account_owners
          WHERE account_global_id = :accountGlobalId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          accountGlobalId: vars.accountGlobalId
        }]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
var account = vars.account
var owners = payload
---
{
  id: account.id as String,
  globalId: account.global_id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: owners map ((owner) -> {
    customerGlobalId: owner.customer_global_id as String,
    relationshipType: owner.relationship_type
  }),
  createdAt: account.created_at,
  updatedAt: account.updated_at
}]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="#[if(vars.accountData.global_id == null) 201 else 200]" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while upserting the account",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /accounts/{accountGlobalId} - Récupérer un compte par Global ID -->
  <flow name="get-account-by-global-id-business-logic" doc:name="get-account-by-global-id-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Account by Global ID">
        <db:sql><![CDATA[
          SELECT *
          FROM global_accounts
          WHERE global_id = :accountGlobalId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          accountGlobalId: vars.accountGlobalId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Account Found?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Store Account">
            <ee:variables>
              <ee:set-variable variableName="account"><![CDATA[%dw 2.0
output application/java
---
payload[0]]]></ee:set-variable>
            </ee:variables>
          </ee:transform>

          <db:select config-ref="Database_Config" doc:name="Get Owners">
            <db:sql><![CDATA[
              SELECT customer_global_id, relationship_type
              FROM global_account_owners
              WHERE account_global_id = :accountGlobalId::uuid
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{
              accountGlobalId: vars.accountGlobalId
            }]]]></db:input-parameters>
          </db:select>

          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var account = vars.account
var owners = payload
---
{
  id: account.id as String,
  globalId: account.global_id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: owners map ((owner) -> {
    customerGlobalId: owner.customer_global_id as String,
    relationshipType: owner.relationship_type
  }),
  createdAt: account.created_at,
  updatedAt: account.updated_at
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="200" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Account not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="404" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </otherwise>
      </choice>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying the database",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /transactions - Business Logic Flow -->
  <flow name="get-transactions-business-logic" doc:name="get-transactions-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Transactions">
        <db:sql><![CDATA[
          SELECT *
          FROM global_transactions
          WHERE
            (:accountGlobalId::uuid IS NULL OR account_global_id = :accountGlobalId::uuid)
            AND (:startDate::date IS NULL OR transaction_date >= :startDate::date)
            AND (:endDate::date IS NULL OR transaction_date <= :endDate::date)
          ORDER BY transaction_date DESC
          LIMIT :limit::integer OFFSET :offset::integer
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload default {}]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
payload map ((txn) -> {
  id: txn.id as String,
  globalId: txn.global_id as String,
  transactionNumber: txn.transaction_number,
  accountGlobalId: txn.account_global_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountGlobalId: if (txn.related_account_global_id != null) txn.related_account_global_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
})]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="200" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying transactions",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- POST /transactions - Business Logic Flow -->
  <flow name="upsert-transaction-business-logic" doc:name="upsert-transaction-business-logic">
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeTransactionType(tt) = 
  if (tt == null) null
  else if (tt as String == "Debit" or tt as String == "debit" or tt as String == "DEBIT") "Debit"
  else if (tt as String == "Credit" or tt as String == "credit" or tt as String == "CREDIT") "Credit"
  else if (tt as String == "Transfer" or tt as String == "transfer" or tt as String == "TRANSFER") "Transfer"
  else if (tt as String == "Fee" or tt as String == "fee" or tt as String == "FEE") "Fee"
  else if (tt as String == "Interest" or tt as String == "interest" or tt as String == "INTEREST") "Interest"
  else if (tt as String == "Reversal" or tt as String == "reversal" or tt as String == "REVERSAL") "Reversal"
  else if (tt as String == "Dispute" or tt as String == "dispute" or tt as String == "DISPUTE") "Dispute"
  else tt as String
fun normalizeTransactionStatus(s) = 
  if (s == null) "Posted"
  else if (s as String == "Pending" or s as String == "pending" or s as String == "PENDING") "Pending"
  else if (s as String == "Posted" or s as String == "posted" or s as String == "POSTED") "Posted"
  else if (s as String == "Cleared" or s as String == "cleared" or s as String == "CLEARED") "Cleared"
  else if (s as String == "Reversed" or s as String == "reversed" or s as String == "REVERSED") "Reversed"
  else if (s as String == "Disputed" or s as String == "disputed" or s as String == "DISPUTED") "Disputed"
  else if (s as String == "Resolved" or s as String == "resolved" or s as String == "RESOLVED") "Resolved"
  else s as String
fun normalizeDisputeStatus(ds) = 
  if (ds == null) "None"
  else if (ds as String == "None" or ds as String == "none" or ds as String == "NONE") "None"
  else if (ds as String == "Initiated" or ds as String == "initiated" or ds as String == "INITIATED") "Initiated"
  else if (ds as String == "UnderReview" or ds as String == "underreview" or ds as String == "UNDERREVIEW") "UnderReview"
  else if (ds as String == "Resolved" or ds as String == "resolved" or ds as String == "RESOLVED") "Resolved"
  else if (ds as String == "Rejected" or ds as String == "rejected" or ds as String == "REJECTED") "Rejected"
  else ds as String
fun cleanDateTimeString(dt: String) = do {
  // Trouve l'index du point décimal après les secondes
  var dotIndex = dt indexOf "."
  var plusIndex = dt indexOf "+"
  var minusLastIndex = dt lastIndexOf "-"
  // Détermine où se trouve le fuseau horaire
  var tzIndex = if (plusIndex > 10) plusIndex else if (minusLastIndex > 10) minusLastIndex else -1
  ---
  if (dotIndex >= 0 and tzIndex > dotIndex)
    // Garde seulement 3 chiffres après le point (millisecondes)
    (dt[0 to dotIndex + 3]) ++ (dt[tzIndex to -1])
  else if (dotIndex >= 0 and tzIndex < 0)
    // Pas de fuseau horaire, garde seulement 3 chiffres après le point
    dt[0 to dotIndex + 3]
  else
    // Pas de millisecondes/nanosecondes à nettoyer
    dt
}
fun parseDateTime(dt) = 
  if (dt == null) null
  else if (dt is String) do {
    var cleaned = cleanDateTimeString(dt as String)
    // Enlève le Z final pour les dates simples (yyyy-MM-ddZ -> yyyy-MM-dd)
    var normalizedDate = if (cleaned matches /^\d{4}-\d{2}-\d{2}Z$/) 
      cleaned[0 to -2] 
      else cleaned
    ---
    if (normalizedDate matches /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}[+-]\d{2}:\d{2}$/)
      normalizedDate as DateTime {format: "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"}
    else if (normalizedDate matches /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}[+-]\d{2}:\d{2}$/)
      normalizedDate as DateTime {format: "yyyy-MM-dd'T'HH:mm:ssXXX"}
    else if (normalizedDate matches /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}$/)
      normalizedDate as LocalDateTime {format: "yyyy-MM-dd'T'HH:mm:ss.SSS"}
    else if (normalizedDate matches /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/)
      normalizedDate as LocalDateTime {format: "yyyy-MM-dd'T'HH:mm:ss"}
    else if (normalizedDate matches /^\d{4}-\d{2}-\d{2}$/)
      normalizedDate as Date {format: "yyyy-MM-dd"}
    else
      normalizedDate as String
  }
  else dt as LocalDateTime
---
{
  global_id: payload.globalId default null,
  transaction_number: payload.transactionNumber,
  account_global_id: payload.accountGlobalId,
  transaction_type: normalizeTransactionType(payload.transactionType),
  amount: payload.amount,
  currency: payload.currency default "USD",
  transaction_date: if (payload.transactionDate != null)
    (parseDateTime(payload.transactionDate) as String {format: "yyyy-MM-dd HH:mm:ss.SSS"})
    else null,
  value_date: if (payload.valueDate != null)
    (parseDateTime(payload.valueDate) as String {format: "yyyy-MM-dd"})
    else "",
  description: payload.description default null,
  merchant_name: payload.merchantName default null,
  category: payload.category default null,
  check_number: payload.checkNumber default null,
  reference_number: payload.referenceNumber default null,
  related_account_global_id: payload.relatedAccountGlobalId default null,
  status: normalizeTransactionStatus(payload.status),
  dispute_status: normalizeDisputeStatus(payload.disputeStatus),
  dispute_reason: payload.disputeReason default null
}]]></ee:set-payload>
      </ee:message>
    </ee:transform>

    <set-variable value="#[payload.transaction_number]" variableName="transactionNumber" doc:name="Store Transaction Number" />

    <try doc:name="Try">
      <db:insert config-ref="Database_Config" doc:name="Upsert Transaction">
        <db:sql><![CDATA[
          INSERT INTO global_transactions (
            global_id, transaction_number, account_global_id, transaction_type, amount,
            currency, transaction_date, value_date, description, merchant_name, category,
            check_number, reference_number, related_account_global_id, status,
            dispute_status, dispute_reason
          )
          VALUES (
            COALESCE(:global_id::uuid, gen_random_uuid()),
            :transaction_number, :account_global_id::uuid, :transaction_type, :amount,
            :currency, COALESCE(TO_TIMESTAMP(:transaction_date, 'YYYY-MM-DD HH24:MI:SS.MS'), CURRENT_TIMESTAMP), NULLIF(:value_date, '')::date, :description, :merchant_name, :category,
            :check_number, :reference_number, :related_account_global_id::uuid, :status,
            :dispute_status, :dispute_reason
          )
          ON CONFLICT (global_id) DO UPDATE SET
            transaction_number = EXCLUDED.transaction_number,
            account_global_id = EXCLUDED.account_global_id,
            transaction_type = EXCLUDED.transaction_type,
            amount = EXCLUDED.amount,
            currency = EXCLUDED.currency,
            transaction_date = EXCLUDED.transaction_date,
            value_date = EXCLUDED.value_date,
            description = EXCLUDED.description,
            merchant_name = EXCLUDED.merchant_name,
            category = EXCLUDED.category,
            check_number = EXCLUDED.check_number,
            reference_number = EXCLUDED.reference_number,
            related_account_global_id = EXCLUDED.related_account_global_id,
            status = EXCLUDED.status,
            dispute_status = EXCLUDED.dispute_status,
            dispute_reason = EXCLUDED.dispute_reason,
            updated_at = CURRENT_TIMESTAMP
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:insert>

      <db:select config-ref="Database_Config" doc:name="Select Upserted Transaction">
        <db:sql><![CDATA[
          SELECT *
          FROM global_transactions
          WHERE transaction_number = :transactionNumber
          ORDER BY updated_at DESC, created_at DESC
          LIMIT 1
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          transactionNumber: vars.transactionNumber
        }]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Store Transaction">
        <ee:variables>
          <ee:set-variable variableName="transaction"><![CDATA[%dw 2.0
output application/java
---
payload[0] default {}]]></ee:set-variable>
        </ee:variables>
      </ee:transform>

      <set-variable value="#[if(vars.transaction.global_id != null and vars.transaction.created_at == vars.transaction.updated_at) 201 else 200]" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
var txn = vars.transaction
---
{
  id: txn.id as String,
  globalId: txn.global_id as String,
  transactionNumber: txn.transaction_number,
  accountGlobalId: txn.account_global_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountGlobalId: if (txn.related_account_global_id != null) txn.related_account_global_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
}]]></ee:set-payload>
        </ee:message>
      </ee:transform>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while upserting the transaction",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /cards - Business Logic Flow -->
  <flow name="get-cards-business-logic" doc:name="get-cards-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Global Cards">
        <db:sql><![CDATA[
          SELECT *
          FROM global_cards
          WHERE
            (:customerGlobalId::uuid IS NULL OR customer_global_id = :customerGlobalId::uuid)
            AND (:accountGlobalId::uuid IS NULL OR account_global_id = :accountGlobalId::uuid)
          ORDER BY created_at DESC
          LIMIT :limit::integer OFFSET :offset::integer
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload default {}]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
payload map ((card) -> {
  id: card.id as String,
  globalId: card.global_id as String,
  cardNumber: card.card_number,
  cardType: card.card_type,
  cardNetwork: card.card_network,
  customerGlobalId: card.customer_global_id as String,
  accountGlobalId: if (card.account_global_id != null) card.account_global_id as String else null,
  cardholderName: card.cardholder_name,
  expirationDate: card.expiration_date,
  status: card.status,
  creditLimit: card.credit_limit,
  availableCredit: card.available_credit,
  controls: {
    dailyPurchaseLimit: card.daily_purchase_limit,
    dailyATMWithdrawalLimit: card.daily_atm_withdrawal_limit,
    internationalTransactionsEnabled: card.international_transactions_enabled,
    onlineTransactionsEnabled: card.online_transactions_enabled
  },
  issuedDate: card.issued_date,
  createdAt: card.created_at,
  updatedAt: card.updated_at
})]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="200" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying cards",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- POST /cards - Upsert Card -->
  <flow name="upsert-card-business-logic" doc:name="upsert-card-business-logic">
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
var controls = payload.controls default {}
fun normalizeCardType(ct) = 
  if (ct == null) null
  else if (ct as String == "CreditCard" or ct as String == "creditcard" or ct as String == "CREDITCARD" or ct as String == "Credit" or ct as String == "credit") "CreditCard"
  else if (ct as String == "DebitCard" or ct as String == "debitcard" or ct as String == "DEBITCARD" or ct as String == "Debit" or ct as String == "debit") "DebitCard"
  else if (ct as String == "PrepaidCard" or ct as String == "prepaidcard" or ct as String == "PREPAIDCARD" or ct as String == "Prepaid" or ct as String == "prepaid") "PrepaidCard"
  else ct as String
fun normalizeCardNetwork(cn) = 
  if (cn == null) null
  else if (cn as String == "Visa" or cn as String == "visa" or cn as String == "VISA") "Visa"
  else if (cn as String == "Mastercard" or cn as String == "mastercard" or cn as String == "MASTERCARD") "Mastercard"
  else if (cn as String == "AmericanExpress" or cn as String == "americanexpress" or cn as String == "AMERICANEXPRESS" or cn as String == "Amex" or cn as String == "amex") "AmericanExpress"
  else if (cn as String == "Discover" or cn as String == "discover" or cn as String == "DISCOVER") "Discover"
  else cn as String
fun normalizeCardStatus(s) = 
  if (s == null) "Active"
  else if (s as String == "Active" or s as String == "active" or s as String == "ACTIVE") "Active"
  else if (s as String == "Inactive" or s as String == "inactive" or s as String == "INACTIVE") "Inactive"
  else if (s as String == "Blocked" or s as String == "blocked" or s as String == "BLOCKED") "Blocked"
  else if (s as String == "Expired" or s as String == "expired" or s as String == "EXPIRED") "Expired"
  else if (s as String == "Cancelled" or s as String == "cancelled" or s as String == "CANCELLED" or s as String == "Canceled" or s as String == "canceled") "Cancelled"
  else s as String
---
{
  global_id: payload.globalId default null,
  card_number: payload.cardNumber,
  card_type: normalizeCardType(payload.cardType),
  card_network: normalizeCardNetwork(payload.cardNetwork),
  customer_global_id: payload.customerGlobalId,
  account_global_id: payload.accountGlobalId default null,
  cardholder_name: payload.cardholderName default null,
  expiration_date: payload.expirationDate default null,
  status: normalizeCardStatus(payload.status),
  credit_limit: payload.creditLimit default null,
  available_credit: payload.availableCredit default payload.creditLimit default null,
  daily_purchase_limit: controls.dailyPurchaseLimit default null,
  daily_atm_withdrawal_limit: controls.dailyATMWithdrawalLimit default null,
  international_transactions_enabled: controls.internationalTransactionsEnabled default true,
  online_transactions_enabled: controls.onlineTransactionsEnabled default true,
  issued_date: payload.issuedDate default null
}]]></ee:set-payload>
      </ee:message>
    </ee:transform>

    <set-variable value="#[payload.card_number]" variableName="cardNumber" doc:name="Store Card Number" />

    <try doc:name="Try">
      <db:insert config-ref="Database_Config" doc:name="Upsert Card">
        <db:sql><![CDATA[
          INSERT INTO global_cards (
            global_id, card_number, card_type, card_network, customer_global_id, account_global_id,
            cardholder_name, expiration_date, status, credit_limit, available_credit,
            daily_purchase_limit, daily_atm_withdrawal_limit,
            international_transactions_enabled, online_transactions_enabled, issued_date
          )
          VALUES (
            COALESCE(:global_id::uuid, gen_random_uuid()),
            :card_number, :card_type, :card_network, :customer_global_id::uuid, :account_global_id::uuid,
            :cardholder_name, :expiration_date::date, :status, :credit_limit, :available_credit,
            :daily_purchase_limit, :daily_atm_withdrawal_limit,
            :international_transactions_enabled, :online_transactions_enabled, :issued_date::date
          )
          ON CONFLICT (global_id) DO UPDATE SET
            card_number = EXCLUDED.card_number,
            card_type = EXCLUDED.card_type,
            card_network = EXCLUDED.card_network,
            customer_global_id = EXCLUDED.customer_global_id,
            account_global_id = EXCLUDED.account_global_id,
            cardholder_name = EXCLUDED.cardholder_name,
            expiration_date = EXCLUDED.expiration_date,
            status = EXCLUDED.status,
            credit_limit = EXCLUDED.credit_limit,
            available_credit = EXCLUDED.available_credit,
            daily_purchase_limit = EXCLUDED.daily_purchase_limit,
            daily_atm_withdrawal_limit = EXCLUDED.daily_atm_withdrawal_limit,
            international_transactions_enabled = EXCLUDED.international_transactions_enabled,
            online_transactions_enabled = EXCLUDED.online_transactions_enabled,
            issued_date = EXCLUDED.issued_date,
            updated_at = CURRENT_TIMESTAMP
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:insert>

      <db:select config-ref="Database_Config" doc:name="Select Upserted Card">
        <db:sql><![CDATA[
          SELECT *
          FROM global_cards
          WHERE card_number = :cardNumber
          ORDER BY updated_at DESC, created_at DESC
          LIMIT 1
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          cardNumber: vars.cardNumber
        }]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Store Card">
        <ee:variables>
          <ee:set-variable variableName="card"><![CDATA[%dw 2.0
output application/java
---
payload[0] default {}]]></ee:set-variable>
        </ee:variables>
      </ee:transform>

      <set-variable value="#[if(vars.card.global_id != null and vars.card.created_at == vars.card.updated_at) 201 else 200]" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
var card = vars.card
---
{
  id: card.id as String,
  globalId: card.global_id as String,
  cardNumber: card.card_number,
  cardType: card.card_type,
  cardNetwork: card.card_network,
  customerGlobalId: card.customer_global_id as String,
  accountGlobalId: if (card.account_global_id != null) card.account_global_id as String else null,
  cardholderName: card.cardholder_name,
  expirationDate: card.expiration_date,
  status: card.status,
  creditLimit: card.credit_limit,
  availableCredit: card.available_credit,
  controls: {
    dailyPurchaseLimit: card.daily_purchase_limit,
    dailyATMWithdrawalLimit: card.daily_atm_withdrawal_limit,
    internationalTransactionsEnabled: card.international_transactions_enabled,
    onlineTransactionsEnabled: card.online_transactions_enabled
  },
  issuedDate: card.issued_date,
  createdAt: card.created_at,
  updatedAt: card.updated_at
}]]></ee:set-payload>
        </ee:message>
      </ee:transform>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while upserting the card",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /cards/{cardGlobalId} - Get Card by Global ID -->
  <flow name="get-card-by-global-id-business-logic" doc:name="get-card-by-global-id-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Card by Global ID">
        <db:sql><![CDATA[
          SELECT *
          FROM global_cards
          WHERE global_id = :cardGlobalId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          cardGlobalId: attributes.uriParams.cardGlobalId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Card Found?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var card = payload[0]
---
{
  id: card.id as String,
  globalId: card.global_id as String,
  cardNumber: card.card_number,
  cardType: card.card_type,
  cardNetwork: card.card_network,
  customerGlobalId: card.customer_global_id as String,
  accountGlobalId: if (card.account_global_id != null) card.account_global_id as String else null,
  cardholderName: card.cardholder_name,
  expirationDate: card.expiration_date,
  status: card.status,
  creditLimit: card.credit_limit,
  availableCredit: card.available_credit,
  dailyPurchaseLimit: card.daily_purchase_limit,
  dailyAtmWithdrawalLimit: card.daily_atm_withdrawal_limit,
  internationalTransactionsEnabled: card.international_transactions_enabled,
  onlineTransactionsEnabled: card.online_transactions_enabled,
  issuedDate: card.issued_date,
  createdAt: card.created_at as String ++ "Z",
  updatedAt: card.updated_at as String ++ "Z"
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="200" doc:name="httpStatus" variableName="httpStatus"/>
        </when>
        <otherwise>
          <ee:transform doc:name="Card Not Found">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Card with globalId " ++ attributes.uriParams.cardGlobalId ++ " not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="404" doc:name="httpStatus" variableName="httpStatus"/>
        </otherwise>
      </choice>

      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while fetching card",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- PUT /cards/{cardGlobalId} - Update Card -->
  <flow name="update-card-business-logic" doc:name="update-card-business-logic">
    <try doc:name="Try">
      <ee:transform doc:name="Transform Request to DB Format">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeCardType(ct) = 
  if (ct == null) null
  else if (ct as String == "CreditCard" or ct as String == "creditcard" or ct as String == "CREDITCARD" or ct as String == "Credit" or ct as String == "credit") "CreditCard"
  else if (ct as String == "DebitCard" or ct as String == "debitcard" or ct as String == "DEBITCARD" or ct as String == "Debit" or ct as String == "debit") "DebitCard"
  else if (ct as String == "PrepaidCard" or ct as String == "prepaidcard" or ct as String == "PREPAIDCARD" or ct as String == "Prepaid" or ct as String == "prepaid") "PrepaidCard"
  else ct as String
fun normalizeCardStatus(s) = 
  if (s == null) null
  else if (s as String == "Active" or s as String == "active" or s as String == "ACTIVE") "Active"
  else if (s as String == "Inactive" or s as String == "inactive" or s as String == "INACTIVE") "Inactive"
  else if (s as String == "Blocked" or s as String == "blocked" or s as String == "BLOCKED") "Blocked"
  else if (s as String == "Expired" or s as String == "expired" or s as String == "EXPIRED") "Expired"
  else if (s as String == "Cancelled" or s as String == "cancelled" or s as String == "CANCELLED") "Cancelled"
  else s as String
---
{
  cardGlobalId: vars.cardGlobalId,
  cardNumber: payload.cardNumber,
  cardType: normalizeCardType(payload.cardType),
  cardNetwork: payload.cardNetwork,
  customerGlobalId: payload.customerGlobalId,
  accountGlobalId: payload.accountGlobalId,
  cardholderName: payload.cardholderName,
  expirationDate: payload.expirationDate,
  status: normalizeCardStatus(payload.status),
  creditLimit: payload.creditLimit,
  availableCredit: payload.availableCredit,
  dailyPurchaseLimit: payload.dailyPurchaseLimit,
  dailyAtmWithdrawalLimit: payload.dailyAtmWithdrawalLimit,
  internationalTransactionsEnabled: payload.internationalTransactionsEnabled,
  onlineTransactionsEnabled: payload.onlineTransactionsEnabled,
  issuedDate: payload.issuedDate
}]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <db:update config-ref="Database_Config" doc:name="Update Card">
        <db:sql><![CDATA[
          UPDATE global_cards
          SET
            card_number = COALESCE(:cardNumber, card_number),
            card_type = COALESCE(:cardType, card_type),
            card_network = COALESCE(:cardNetwork, card_network),
            customer_global_id = COALESCE(:customerGlobalId::uuid, customer_global_id),
            account_global_id = COALESCE(:accountGlobalId::uuid, account_global_id),
            cardholder_name = COALESCE(:cardholderName, cardholder_name),
            expiration_date = COALESCE(:expirationDate::date, expiration_date),
            status = COALESCE(:status, status),
            credit_limit = COALESCE(:creditLimit, credit_limit),
            available_credit = COALESCE(:availableCredit, available_credit),
            daily_purchase_limit = COALESCE(:dailyPurchaseLimit, daily_purchase_limit),
            daily_atm_withdrawal_limit = COALESCE(:dailyAtmWithdrawalLimit, daily_atm_withdrawal_limit),
            international_transactions_enabled = COALESCE(:internationalTransactionsEnabled, international_transactions_enabled),
            online_transactions_enabled = COALESCE(:onlineTransactionsEnabled, online_transactions_enabled),
            issued_date = COALESCE(:issuedDate::date, issued_date),
            updated_at = CURRENT_TIMESTAMP
          WHERE global_id = :cardGlobalId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:update>

      <!-- Fetch the updated card -->
      <db:select config-ref="Database_Config" doc:name="Select Updated Card">
        <db:sql><![CDATA[
          SELECT *
          FROM global_cards
          WHERE global_id = :cardGlobalId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          cardGlobalId: vars.cardGlobalId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Card Found?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var card = payload[0]
---
{
  id: card.id as String,
  globalId: card.global_id as String,
  cardNumber: card.card_number,
  cardType: card.card_type,
  cardNetwork: card.card_network,
  customerGlobalId: card.customer_global_id as String,
  accountGlobalId: if (card.account_global_id != null) card.account_global_id as String else null,
  cardholderName: card.cardholder_name,
  expirationDate: card.expiration_date,
  status: card.status,
  creditLimit: card.credit_limit,
  availableCredit: card.available_credit,
  dailyPurchaseLimit: card.daily_purchase_limit,
  dailyAtmWithdrawalLimit: card.daily_atm_withdrawal_limit,
  internationalTransactionsEnabled: card.international_transactions_enabled,
  onlineTransactionsEnabled: card.online_transactions_enabled,
  issuedDate: card.issued_date,
  createdAt: card.created_at as String ++ "Z",
  updatedAt: card.updated_at as String ++ "Z"
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="200" doc:name="httpStatus" variableName="httpStatus"/>
        </when>
        <otherwise>
          <ee:transform doc:name="Card Not Found">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Card with globalId " ++ vars.cardGlobalId ++ " not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="404" doc:name="httpStatus" variableName="httpStatus"/>
        </otherwise>
      </choice>

      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while updating card",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

</mule>
